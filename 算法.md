# 动态规划

## 打家劫舍

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  if (!nums || nums.length === 0) {
    return 0;
  }
  let dp0 = 0,
    dp1 = nums[0],
    len = nums.length;
  for (let i = 1; i < len; i++) {
    let temp = Math.max(dp0, dp1);
    dp1 = dp0 + nums[i];
    dp0 = temp;
  }
  return Math.max(dp0, dp1);
};

```



## 买卖股票的最佳时机

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
/* 动态规划 */
var maxProfit = function (prices) {
  if (prices == null || prices.length == 0) return 0;
  let sold = 0,
    buy = -prices[0];
  for (let i in prices) {
    sold = Math.max(sold, buy + prices[i]);
    buy = Math.max(buy, -prices[i]);
  }
  return sold;
};
/**
 * @param {number[]} prices
 * @return {number}
 */
/* 双指针 */
var maxProfit = function (prices) {
  if (prices == null || prices.length == 0) return 0;
  let min = prices[0],
    max = 0;
  for (let i in prices) {
    min = Math.min(min, prices[i]);
    max = Math.max(max, prices[i] - min);
  }
  return max;
};
/**
 * @param {number[]} prices
 * @return {number}
 */
/* 最大子序和 */
var maxProfit = function (prices) {
  if (prices == null || prices.length == 0) return 0;
  let cur = 0,
    max = 0;
  for (let i = 1; i < prices.length; i++) {
    cur = Math.max(cur, 0) + prices[i] - prices[i - 1];
    max = Math.max(max, cur);
  }
  return max;
};

```



## 爬楼梯

```js
/**
 * @param {number} n
 * @return {number}
 */
/* 尾递归 */
var climbStairs = function (n) {
  return calcNums(n, 1, 1);
};
function calcNums(n, a, b) {
  if (n <= 1) {
    return b;
  }
  return calcNums(n, b, a + b);
}

/* 非递归循环 */
var climbStairs = function (n) {
  if (n <= 1) {
    return 1;
  }
  let dpi = [];
  dpi[1] = 1;
  dpi[2] = 2;
  for (let i = 3; i <= n; i++) {
    dpi[i] = dpi[i - 1] + dpi[i - 2];
  }
  return dpi[n];
};
console.log(climbStairs(4));

```



## 最大子序和

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  if (!nums || nums.length === 0) {
    return 0;
  }
  let cur = nums[0],
    max = nums[0];
  for (let i = 1; i < nums.length; i++) {
    cur = Math.max(cur, 0) + nums[i];
    max = Math.max(cur, max);
  }
  return max;
};

```



# 链表

## 反转链表

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
/* 递归 */
var reverseList = function (head) {
  if (head === null) {
    return null;
  }
  let json = { node: null };
  reverseNode(head, json);
  head.next = null;
  return json.node;
};

function reverseNode(node, json) {
  if (node.next !== null) {
    let prevNode = reverseNode(node.next, json);
    prevNode.next = node;
  } else {
    json.node = node;
  }
  return node;
}

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
/* 迭代 */
var reverseList = function (head) {
  let arr = [];
  while (head !== null) {
    arr.push(head);
    head = head.next;
  }
  if (arr.length === 0) {
  }
  let node = arr.pop(),
    newHead = node;
  for (let i = 0; arr.length !== 0; i++) {
    node.next = arr.pop();
    node = node.next;
  }
  node.next = null;
  return newHead;
};

```



## 合并两个有序列表

```js
//   Definition for singly-linked list.
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
/* 使用第三个列表 */
var mergeTwoLists = function (l1, l2) {
  let dump = new ListNode(0);
  let cur = dump;
  while (l1 !== null && l2 !== null) {
    if (l1.val >= l2.val) {
      cur.next = l2;
      l2 = l2.next;
    } else {
      cur.next = l1;
      l1 = l1.next;
    }
    cur = cur.next;
  }
  cur.next = l1 == null ? l2 : l1;
  return dump.next;
};

```



## 环形链表

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
/* 快慢指针 */
var hasCycle = function (head) {
  let slow = head,
    fast = head;
  while (fast != null && fast.next !== null) {
    fast = fast.next.next;
    slow = slow.next;
    if (fast === slow) {
      return true;
    }
  }
  return false;
};

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
/* 集合 */
var hasCycle = function (head) {
  let map = new Map();

  while (head != null) {
    if (map.has(head)) {
      return true;
    } else {
      map.set(head, head.val);
    }
    head = head.next;
  }
  return false;
};

```



## 回文链表

```js
//   Definition for singly-linked list.
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

/**
 * @param {ListNode} head
 * @return {boolean}
 */
/* 栈 */
var isPalindrome = function (head) {
  let fast = head,
    slow = head,
    stack = [];
  while (fast !== null && fast.next !== null) {
    fast = fast.next.next;
    stack.push(slow.val);
    slow = slow.next;
  }
  if (fast !== null) {
    slow = slow.next;
  }
  while (slow !== null) {
    if (stack.pop() !== slow.val) {
      return false;
    }
    slow = slow.next;
  }
  return true;
};
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
/* 反转后半部分链表 */
var isPalindrome = function (head) {
  let fast = head,
    slow = head;
  while (fast !== null && fast.next !== null) {
    fast = fast.next.next;
    slow = slow.next;
  }
  if (fast !== null) {
    slow = slow.next;
  }
  slow = reverse(slow);
  fast = head;
  while (slow !== nul) {
    if (fast.val !== slow.val) {
      return false;
    }
    fast = fast.next;
    slow = slow.next;
  }
  return true;
};

function reverse(node) {
  let prev = null;
  while (node !== null) {
    let head = node.next;
    node.next = prev;
    prev = node;
    node = head;
  }
  return prev;
}

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
/* 递归 */
var isPalindrome = function (head) {
  return reversex(head, head) === null ? true : false;
};

function reversex(node, head) {
  if (node.next != null) {
    let flag = reversex(node.next, head);
    if (!flag) {
      return false;
    }
    head = flag;
  }
  console.log(node, head);
  if (node.val === head.val) {
    return head.next;
  }
  return false;
}

let a1 = new ListNode(1);
let a2 = new ListNode(2);
let a3 = new ListNode(2);
let a4 = new ListNode(1);
let a5 = new ListNode(5);
a1.next = a2;
a2.next = a3;
a3.next = a4;
console.log(isPalindrome(a1));

```



## 删除链表的倒数第N个

```js
// Definition for singly-linked list.
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
/* 递归 */
var removeNthFromEnd = function (head, n) {
  if (head === null) {
    return [];
  }
  searchNode(head, n, head);
  return head;
};

function searchNode(node, n, head) {
  let json = {};
  if (node.next && n) {
    json = searchNode(node.next, n, head);
    if (json === null) {
      return null;
    }
  } else {
    return { flag: true, n: --n };
  }

  if (json.n === 0) {
    node.next = node.next.next;
    return null;
  }

  if (node === head) {
    node.val = node.next.val;
    node.next = node.next.next;
    return null;
  }
  if (json.flag) {
    return { flag: true, n: --json.n };
  }
}
let a1 = new ListNode(1);
let a2 = new ListNode(2);
let a3 = new ListNode(3);
let a4 = new ListNode(4);
let a5 = new ListNode(5);
a1.next = a2;
// a2.next = a3;
// a3.next = a4;
// a4.next = a5;
function print() {
  let head = removeNthFromEnd(a1, 2);
  while (head.next !== null) {
    console.log(head);
    head = head.next;
  }
}
print();

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
/* 双指针 */
var removeNthFromEnd = function (head, n) {
  let first = head,
    slow = head;
  for (let i = 0; i < n; i++) {
    first = first.next;
  }
  if (first === null) {
    return head.next;
  }
  while (first.next != null) {
    first = first.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return head;
};

```



# 排序和搜索

## 第一个错误的版本

```js
/**
 * Definition for isBadVersion()
 *
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */

/**
 * @param {function} isBadVersion()
 * @return {function}
 */
var solution = function (isBadVersion) {
  /**
   * @param {integer} n Total versions
   * @return {integer} The first bad version
   */
  return function (n) {
    let m = n >> 1,
      left = 0,
      right = n;
    while (left < right) {
      m = parseInt((left + right) / 2);
      if (!isBadVersion(m)) {
        left = m + 1;
      } else {
        right = m;
      }
    }
    return left;
  };
};

```



## 合并两个有序数组

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
  let i = m - 1,
    j = n - 1,
    len = nums1.length - 1;
  while (i >= 0 && j >= 0) {
    if (nums1[i] >= nums2[j]) {
      nums1[len] = nums1[i];
      len--;
      i--;
    } else {
      nums1[len] = nums2[j];
      len--;
      j--;
    }
    console.log(nums1);
  }

  while (j >= 0) {
    nums1[len] = nums2[j];
    j--;
    len--;
    console.log(nums1);
  }
};
merge([0], 0, [1], 1);

```



# 设计问题

## 打乱数组

```js
/**
 * @param {number[]} nums
 */
var Solution = function (nums) {
  this.nums = nums;
};

/**
 * Resets the array to its original configuration and return it.
 * @return {number[]}
 */
Solution.prototype.reset = function () {
  return this.nums;
};

/**
 * Returns a random shuffling of the array.
 * @return {number[]}
 */
Solution.prototype.shuffle = function () {
  let nums = Object.assign([], this.nums),
    len = this.nums.length;
  for (let i = 1; i < len; i++) {
    let a1 = Math.floor(Math.random() * len);
    let temp = nums[a1];
    nums[a1] = nums[len - 1];
    nums[len - 1] = temp;
  }
  return nums;
};

/**
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(nums)
 * var param_1 = obj.reset()
 * var param_2 = obj.shuffle()
 */

```



# 树

## 对称二叉树

```js
// Definition for a binary tree node.
function TreeNode(val, left, right) {
  this.val = val === undefined ? 0 : val;
  this.left = left === undefined ? null : left;
  this.right = right === undefined ? null : right;
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
  if (!root) return true;
  return symmetric(root.left, root.right);
};
function symmetric(left, right) {
  if (left === null && right === null) {
    return true;
  }
  if (left === null || right === null || left.val !== right.val) {
    return false;
  }
  return symmetric(left.left, right.right) && symmetric(left.right, right.left);
}
let a0 = new TreeNode();
let a1 = new TreeNode(1);
let a2 = new TreeNode(2);
let a3 = new TreeNode(2);
let a4 = new TreeNode(2);
let a5 = new TreeNode(2);
let a6 = new TreeNode(2);
a1.left = a2;
a1.right = a3;
a3.left = a4;
// a3.right = a5;
a2.left = a6;
a2.right = a0;
console.log(a1);
console.log(isSymmetric(a1));

```



## 二叉树的层序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
/* 循环-广度遍历 */
var levelOrder = function (root) {
  if (!root) {
    return [];
  }
  let stack = [root],
    res = [];

  while (stack.length !== 0) {
    let level = [],
      len = stack.length;
    while (len-- > 0) {
      let node = stack.shift();
      level.push(node.val);
      if (node.left) {
        stack.push(node.left);
      }
      if (node.right) {
        stack.push(node.right);
      }
    }
    res.push(level);
  }
  return res;
};
/* 递归-深度遍历 */
var levelOrder = function (root) {
  if (!root) {
    return [];
  }
  let depth = 0,
    res = [];
  function level(root, depth) {
    if (res[depth]) {
      res[depth].push(root.val);
    } else {
      res[depth] = [root.val];
    }
    ++depth;
    if (root.left) {
      level(root.left, depth);
    }
    if (root.right) {
      level(root.right, depth);
    }
  }
  level(root, depth);
  return res;
};

```



## 二叉树的最大深度

```js
// Definition for a binary tree node.
function TreeNode(val, left, right) {
  this.val = val === undefined ? 0 : val;
  this.left = left === undefined ? null : left;
  this.right = right === undefined ? null : right;
}

/**
 * @param {TreeNode} root
 * @return {number}
 */ /* 递归 */
var maxDepth = function (root) {
  if (!root) {
    return 0;
  }
  let index = 0,
    max = 0;
  max = calcDepth(root, index, max);
  return max;
};
function calcDepth(root, index, max) {
  index++;
  max = Math.max(index, max);
  if (root.left) {
    max = calcDepth(root.left, index, max);
  }
  if (root.right) {
    max = calcDepth(root.right, index, max);
  }
  index--;
  return max;
}
var maxDepth = function (root) {
  return root === null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};
let a1 = new TreeNode(3);
let a2 = new TreeNode(9);
let a3 = new TreeNode(20);
let a4 = new TreeNode(15);
let a5 = new TreeNode(7);
a1.left = a2;
a1.right = a3;
a3.left = a4;
a3.right = a5;
console.log(maxDepth(a1));

```



## 验证二叉搜索树

```js
// Definition for a binary tree node.
function TreeNode(val, left, right) {
  this.val = val === undefined ? 0 : val;
  this.left = left === undefined ? null : left;
  this.right = right === undefined ? null : right;
}

/**
 * @param {TreeNode} root
 * @return {boolean}
 */
/* 递归 */
var isValidBST = function (root) {
  return validBST(root, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
};
function validBST(root, minVal, maxVal) {
  if (root.val !== null) {
    return true;
  }
  if (root.val <= minVal || root.val >= maxVal) {
    return false;
  }
  return validBST(root.left, minVal, root.val) && validBST(root.right, root.val, maxVal);
}
let prev = null;
var isValidBST = function (root) {
  if (!root) {
    return true;
  }
  if (!isValidBST(root.left)) {
    return false;
  }
  if (prev !== null && prev.val >= root.val) {
    return false;
  }
  prev = root;
  if (!isValidBST(root.right)) return false;
  return true;
};
let a0 = new TreeNode(0);
let a1 = new TreeNode(5);
let a2 = new TreeNode(4);
let a3 = new TreeNode(6);
let a4 = new TreeNode(3);
let a5 = new TreeNode(7);
a1.left = a2;
a1.right = a3;
a3.left = a4;
a3.right = a5;
console.log(a0);
console.log(isValidBST(a0));xxxxxxxxxx52 1// Definition for a binary tree node.2function TreeNode(val, left, right) {3  this.val = val === undefined ? 0 : val;4  this.left = left === undefined ? null : left;5  this.right = right === undefined ? null : right;6}78/**9 * @param {TreeNode} root10 * @return {boolean}11 */12/* 递归 */13var isValidBST = function (root) {14  return validBST(root, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);15};16function validBST(root, minVal, maxVal) {17  if (root.val !== null) {18    return true;19  }20  if (root.val <= minVal || root.val >= maxVal) {21    return false;22  }23  return validBST(root.left, minVal, root.val) && validBST(root.right, root.val, maxVal);24}25let prev = null;26var isValidBST = function (root) {27  if (!root) {28    return true;29  }30  if (!isValidBST(root.left)) {31    return false;32  }33  if (prev !== null && prev.val >= root.val) {34    return false;35  }36  prev = root;37  if (!isValidBST(root.right)) return false;38  return true;39};40let a0 = new TreeNode(0);41let a1 = new TreeNode(5);42let a2 = new TreeNode(4);43let a3 = new TreeNode(6);44let a4 = new TreeNode(3);45let a5 = new TreeNode(7);46a1.left = a2;47a1.right = a3;48a3.left = a4;49a3.right = a5;50console.log(a0);51console.log(isValidBST(a0));52js
```



# 数学

## 3的幂

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function (n) {
  return (Math.log10(n) / Math.log10(3)) % 1 == 0;
};

```



## 计数质数

```js
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function (n) {
  let arr = new Array(n).fill(1),
    count = 0;
  for (let i = 2; i <= n; i++) {
    if (arr[i]) {
      count++;
    }
    for (let j = i * 2; j <= n; j += i) {
      arr[j] = 0;
    }
  }
  return count;
};

```



## 罗马数字转整数

```js
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function (s) {
  let json = {
      I: 1,
      V: 5,
      X: 10,
      L: 50,
      C: 100,
      D: 500,
      M: 1000,
    },
    len = s.length;
  let res = 0;
  for (let i = 0; i < len; i++) {
    let num1 = json[s[i]],
      num2 = json[s[i + 1]];
    console.log(num1, num2);
    if (num2 && num1 < num2) {
      res -= num1;
    } else {
      res += num1;
    }
  }
  return res;
};
console.log(romanToInt('III'));

```



## FIZZBUZZ

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function (n) {
  let res = [];
  for (let i = 1; i <= n; i++) {
    if (i % 15 == 0) {
      res.push('FizzBuzz');
    } else if (i % 5 == 0) {
      res.push('Buzz');
    } else if (i % 3 == 0) {
      res.push('Fizz');
    } else {
      res.push('' + i);
    }
  }
  return res;
};

```



# 数组

## 存在重复元素

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
 var containsDuplicate = function(nums) {
  let obj={}
  for(let i=0;i<nums.length;i++){
      if(obj[nums[i]]){
          return true
      }
      obj[nums[i]]=1
  }
  return false
};

function cD(nums){
  return !(nums.length===[...new Set(nums)].length)
}
console.log(cD([1,1,2,3]));
```



## 加一

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
 var plusOne = function(digits) {
  return addOne(digits,digits.length-1)
};

function addOne(digits,index){
  if(index<0){
      index+=1
      digits.unshift(0)
  }
  if((digits[index]+1)===10){
      digits[index]=0
      addOne(digits,index-1)
  }else{
      digits[index]+=1
  }

  return digits
}
```



## 两个数组的交集

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
/* 双指针 */
 var intersect = function(nums1, nums2) {
  nums1.sort((a,b)=>a-b)
  nums2.sort((a,b)=>a-b)
  let res=[]
  for(let i=0,j=0;i<nums1.length&&j<nums2.length;){
      if(nums1[i]===nums2[j]){
          res.push(nums1[i])
          i++
          j++
      }else if(nums1[i]>nums2[j]){
          j++
      }else{
          i++
      }
      console.log(nums1[i],nums2[j]);
  }
  return res
};
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
/* map对象 */
 var intersect = function(nums1, nums2) {
  let map1=new Map(),res=[]

  for(let i in nums1){
      if(map1.has(nums1[i])){
          map1.set(nums1[i],map1.get(nums1[i])+1)
      }else{
          map1.set(nums1[i],1)
      }
  }
  for(let i in nums2){
      if(map1.has(nums2[i])&&map1.get(nums2[i])>0){
          res.push(nums2[i])
           map1.set(nums2[i],map1.get(nums2[i])-1)
      }
  }
  return res
};
```



## 两数之和

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
 var twoSum = function(nums, target) {
  let map = new Map()
  for(let i in nums){
      if(map.get(target-nums[i])){
          return [map.get(target-nums[i]),i]
      }
      map.set(nums[i],i)
  }
  return []
};
```



## 删除排序数组中的重复项

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  if(nums===null||nums.length===0){
      return []
  }
  let left=0,right=1;
  while(right<nums.length){
      if(nums[left]===nums[right]){
          right++
      }else{
          left++
          nums[left]=nums[right]
          right++
      }
      console.log(nums,left,right);
  }
  nums.splice(++left)
  return nums
};
console.log(removeDuplicates([1,1,2]));

```



## 旋转数组

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
/* 添加k位 */
var rotate = function (nums, k) {
  for (let i = 0; i < k; i++) {
    nums.push(0)
  }
  for (let i = nums.length - 1; i - k >= 0; --i) {
    nums[i] = nums[i - k]
  }
  for (let i = k - 1; i >= 0; i--) {
    nums[i] = nums.pop()
  }
};
/* 反转 */
function rotate(nums,k) {
  let length = nums.length;
  k %= length;
  reverse(nums, 0, length - 1);//先反转全部的元素
  reverse(nums, 0, k - 1);//在反转前k个元素
  reverse(nums, k, length - 1);//接着反转剩余的
}


function reverse(nums, start, end) {
  while (start < end) {
    let temp = nums[start];
    nums[start++] = nums[end];
    nums[end--] = temp;
  }
}
```



## 旋转图像

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
/* 上下交换，对角线交换 */
var rotate = function (matrix) {
  let len = matrix.length
  for (let i = 0; i < len / 2; i++) {
    [matrix[i], matrix[len - 1 - i]] = [matrix[len - 1 - i], matrix[i]]
  }
  for (let i = 0; i < len; i++) {
    for (let j = i+1; j < len; j++) {
        [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]
      }
  }
  console.log(matrix);
};
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
/* 直接交换 */
var rotate = function (matrix) {
  let len = matrix.length
  for (let i = 0; i < len / 2; i++) {
   for(let j=i;j<len-i-1;j++){
     let temp=matrix[i][j],m=len-j-1,n=len-i-1
     matrix[i][j]=matrix[m][i]
     matrix[m][i]=matrix[n][m]
     matrix[n][m]=matrix[j][n]
     matrix[j][n]=temp     
   }
  }
  console.log(matrix);
};
rotate([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
])
```



## 移动零

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
/* 双重循环 */
 var moveZeroes = function (nums) {

  for (let i = nums.length - 1; i >= 0;i--) {
      if (nums[i] === 0) {
          for (let j = i; j < nums.length - 1;j++) {
              [nums[j],nums[j+1]]=[nums[j+1],nums[j]]
              console.log([nums[j],nums[j+1]]);
              console.log([j]);
          }
      }
      console.log(nums);
  }
};
/* 移动非零 */
var moveZeroes = function (nums) {
  let index=0
  for (let i in nums) {
    if(nums[i]!==0){
      nums[index++]=nums[i]
    }
  }
  while(index<nums.length){
    nums[index++]=0
  }
};
// 双指针
var moveZeroes = function (nums) {
  let index=0
  for (let i in nums) {
    if(nums[j]===0){
      index++
    }else if(i!=0){
      [nums[j-i],nums[j]]=[nums[j],nums[j-i]]
    }
  }
  
};
moveZeroes([0,1,0,3,12])
```



## 有效的数独

```js
/**
 * @param {character[][]} board
 * @return {boolean}
 */
/* 二维数组直接判断 */
var isValidSudoku = function (board) {
  let len = board.length
  let line = new Array(len),
    column = new Array(len),
    cell = new Array(9)
  for (let i = 0; i < len; i++) {
    line[i] = new Array(len)
    column[i] = new Array(len)
    cell[i] = new Array(len)
  }
  for (let i = 0; i < len; ++i) {
    for (let j = 0; j < len; ++j) {
      if (board[i][j] === '.') {
        continue
      }
      let num = board[i][j] - 1
      let k = parseInt(i / 3) * 3 + parseInt(j / 3)
      if (line[i][num] || column[j][num] || cell[k][num]) {
        console.log(i, j, board[i][j], line[i][num], column[j][num], cell[k][num]);
        return false
      }
      line[i][num] = column[j][num] = cell[k][num] = 1
    }
  }
  return true
};

var isValidSudoku = function (board) {
  let len = board.length
  let line = new Array(len),
    column = new Array(len),
    cell = new Array(len)
  let shift = 0
  for (let i = 0; i < len; ++i) {
    for (let j = 0; j < len; ++j) {
      if (board[i][j] === '.') {
        continue
      }
      shift = 1 << (board[i][j] - '0')
      let k = parseInt(i / 3) * 3 + parseInt(j / 3)
      if (line[i] & shift || column[j] & shift || cell[k] & shift) {
        return false
      }
      console.log(`${line[i]}&${shift}=${line[i] & shift}` );

      line[i] |= shift
      column[j] |= shift
      cell[k] |= shift
    }
  }
  return true
};

let arr = [
  ["5", "3", ".", ".", "7", ".", ".", ".", "."],
  ["6", ".", ".", "1", "9", "5", ".", ".", "."],
  [".", "9", "8", ".", ".", ".", ".", "6", "."],
  ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
  ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
  ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
  [".", "6", ".", ".", ".", ".", "2", "8", "."],
  [".", ".", ".", "4", "1", "9", ".", ".", "5"],
  [".", ".", ".", ".", "8", ".", ".", "7", "9"]
]
isValidSudoku(arr)
```



## 只出现一次的数字

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
/* 异或运算 */
//  var singleNumber = function(nums) {
//   let result=0
//   for(let i in nums){
//       result ^=nums[i]
//   }
//   return result
// };
var singleNumber = function(nums) {
  let set = new Set()
  for(let i in nums){
    if(set.has(nums[i])){
      set.remove(nums[i])
    }
  }
  return [...set][0]
};
singleNumber([1,1,2])
```



# 字符串

## 反转字符串

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function (s) {
  let len = s.length;
  for (let i = 0; i < len / 2; i++) {
    [s[i], s[len - i - 1]] = [s[len - i - 1], s[i]];
  }
};

```



## 实现strStr()

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
/* 逐个判断 */
var strStr = function (haystack, needle) {
  if (haystack === needle || needle === '') {
    return 0;
  }
  let h = haystack.split(''),
    n = needle.split(''),
    j = 0,
    i = 0;
  for (; i < h.length && j < n.length; ) {
    if (h[i] === n[j]) {
      i++;
      j++;
    } else {
      i = i - j + 1;
      j = 0;
    }
  }
  if (j == n.length) {
    return i - j;
  }
  return -1;
};
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
/* 不断截取主字符串进行比较 */
var strStr = function (haystack, needle) {
  if (haystack === needle || needle === '') {
    return 0;
  }
  let len = needle.length;
  for (let i = 0; i < haystack.length - len + 1; i++) {
    if (haystack.substring(i, i + len) === needle) {
      return i;
    }
  }
  return -1;
};

```



## 外观数列

```js
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function (n) {
  if (n == 1) {
    return '1';
  }
  n--;
  return count('1', n);
};

function count(str, n) {
  n--;
  let num = str.split('');
  let res = '';
  let index = 0;
  for (let i = 0; i < num.length - 1; i++) {
    if (num[i] !== num[i + 1]) {
      index++;
      res += index + '' + num[i];
      index = 0;
    } else {
      index++;
    }
  }
  if (num[num.length - 1] === num[num.length - 2]) {
    index++;
    res += index + '' + num[num.length - 1];
  } else {
    res += 1 + '' + num[num.length - 1];
  }
  console.log(res, n);
  if (n > 0) {
    return count(res, n);
  }
  return res;
}
countAndSay(10);

```



## 验证回文串

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function (s) {
  let arr = s.toLowerCase().split(''),
    i = 0,
    j = arr.length - 1;
  let Regx = /^[A-Za-z0-9]*$/;
  for (; i < arr.length && j >= 0; ) {
    if (!Regx.test(arr[i])) {
      i++;
      continue;
    }
    if (!Regx.test(arr[j])) {
      j--;
      continue;
    }
    if (arr[i] !== arr[j]) {
      return false;
    }
    i++;
    j--;
  }
  return true;
};

console.log(isPalindrome('0P'));

```



## 有效字母异位词

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function (s, t) {
  if (s.length !== t.length) {
    return false;
  }
  let mapS = new Map(),
    mapT = new Map();
  for (let i in s) {
    if (mapS.has(s[i])) {
      mapS.set(s[i], mapS.get(s[i]) + 1);
    } else {
      mapS.set(s[i], 1);
    }
    if (mapT.has(t[i])) {
      mapT.set(t[i], mapT.get(t[i]) + 1);
    } else {
      mapT.set(t[i], 1);
    }
  }
  for (let i of mapS.keys()) {
    if (mapS.get(i) !== mapT.get(i)) {
      return false;
    }
  }

  return true;
};
isAnagram('abb', 'aba');

```



## 整数反转

```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function (x) {
  let res = 0;
  while (x != 0) {
    res = res * 10 + (x % 10);
    x = parseInt(x / 10);
    if (Math.abs(res) > Math.pow(2, 31)) {
      return 0;
    }
  }
  return res;
};

```



## 字符串中的第一个唯一字符

```js
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function (s) {
  let arr = s.split(''),
    map = new Map();
  for (let i in arr) {
    if (map.has(arr[i])) {
      map.set(arr[i], 2);
      continue;
    }
    map.set(arr[i], 1);
  }
  for (let i of map.keys()) {
    if (map.get(i) < 2) {
      return arr.indexOf(i);
    }
  }
  return -1;
};
firstUniqChar('loveleetcode');

```



## 字符串转换整数

```js
/**
 * @param {string} s
 * @return {number}
 */
var myAtoi = function (s) {
  let RegNum = /^[0-9]*$/,
    RegCode = /^[A-Za-z]*$/;
  let res = '',
    arr = s.split(''),
    flag = false;
  for (let i in arr) {
    if (arr[i] === '-' || arr[i] === '+' || arr[i] === '.') {
      flag = true;
      res += arr[i];
    }
    if (RegCode.test(arr[i]) || (arr[i] === ' ' && flag)) {
      break;
    }
    if (RegNum.test(arr[i])) {
      flag = true;
      res += arr[i];
    }
  }
  return !parseInt(res)
    ? 0
    : parseInt(res) >= Math.pow(2, 31)
    ? Math.pow(2, 31) - 1
    : parseInt(res) < -Math.pow(2, 31)
    ? -Math.pow(2, 31)
    : parseInt(res);
};

```



## 最长公共前缀

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function (strs) {
  let res = strs[0];
  let local = strs[0];

  for (let i = 0; i < strs.length; i++) {
    let ret = '';
    for (let j = 0; j < local.length; j++) {
      if (strs[i][j] == local[j]) {
        ret += local[j];
      } else {
        break;
      }
    }
    if (ret.length < res.length) {
      res = ret;
    }
  }
  return res;
};

```



# 其他

## 颠倒二进制位

```js
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function (n) {
  let res = 0;
  while (n > 0) {
    res = res << 1;
    res |= n & 1;
    n = n >>> 1;
  }
  res = res >>> 0;
  console.log(res);
  return res;
};

reverseBits(4294967293);

```



## 汉明距离

```js
/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function (x, y) {
  let n = x ^ y,
    count = 0;
  while (n > 0) {
    count += n & 1;
    n = n >> 1;
  }
  return count;
};

```



## 缺失数字

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function (nums) {
  let xor = 0;
  for (let i = 0; i < nums.length; i++) {
    xor = xor ^ nums[i] ^ (i + 1);
  }
  return xor;
};

```



## 位1的个数

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function (n) {
  let count = 0;
  for (let i = 0; i < 32; i++) {
    console.log(n >>> i, (n >>> i) & 1);
    if (((n >>> i) & 1) == 1) {
      count++;
    }
  }
  return count;
};

hammingWeight(11);

```



## 杨辉三角

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function (numRows) {
  let list = [[1]];
  for (let i = 1; i < numRows; i++) {
    list.push([]);
    for (let j = 0; j <= i; j++) {
      if (j === 0 || j === i) {
        list[i].push(1);
      } else {
        list[i].push(list[i - 1][j - 1] + list[i - 1][j]);
      }
    }
  }
  return list;
};

```



## 有效的括号

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
  let stack = [];
  for (let i = 0; i < s.length; i++) {
    let temp = stack[stack.length - 1] || '';
    if (s[i] === '[' || s[i] === '(' || s[i] === '{') {
      stack.push(s[i]);
    } else if (s[i] === ']' && temp === '[') {
      stack.pop();
    } else if (s[i] === '}' && temp === '{') {
      stack.pop();
    } else if (s[i] === ')' && temp === '(') {
      stack.pop();
    } else {
      return false;
    }
  }
  if (stack.length === 0) {
    return true;
  }
  return false;
};

```



# 字符命名转换

```js
链接：https://www.nowcoder.com/questionTerminal/e971233adadb4a44b9ca076c019fd939
来源：牛客网

while(line=readline()){
    let s=line;
    let str="";
    let s1;
    let s2;
    let s3;
    let s4;
    if(s.indexOf('_')>-1||s.indexOf('-')>-1){
        if(s.indexOf('_')>-1){
            s3=s;
            s4=s.split('_').join('-');
        }else if(s.indexOf('-')>-1){
            s4=s;
            s3=s.split('-').join('_');
        }
        s1=s3.split('_').map(item=>item[0].toUpperCase()+item.substr(1)).join("");
        s2=s1[0].toLowerCase()+s1.substr(1);
    }else{
        str=s;
        s1=str[0].toUpperCase()+str.substr(1);
        s2=str[0].toLowerCase()+str.substr(1);
        let str3=s2.split("");
        let str4=s2.split("");
        for(let i=1;i<str.length;i++){
            if(str[i]==str.toUpperCase()[i]){
                str3[i]='_'+str.toLowerCase()[i];
                str4[i]='-'+str.toLowerCase()[i];
            }
        }
        s3=str3.join("");
        s4=str4.join("");
    }
    print([s1,s2,s3,s4].join(" "))
}
```

# 办公室

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] params = br.readLine().trim().split(" ");
        int x = Integer.parseInt(params[0]);
        int y = Integer.parseInt(params[1]);
        int n = Integer.parseInt(params[2]);
        long[][] dp = new long[x + 1][y + 1];
        for(int i = 0; i < n; i++){
            params = br.readLine().split(" ");
            dp[Integer.parseInt(params[0])][Integer.parseInt(params[1])] = -1L;
        }
        for(int i = 0; i <= x; i++) dp[i][0] = 1L;
        for(int j = 0; j <= y; j++) dp[0][j] = 1L;
        for(int i = 1; i <= x; i++){
            for(int j = 1; j <= y; j++){
                if(dp[i][j] == -1) continue;       // 当前是老板的位置
                if(dp[i - 1][j] != -1) dp[i][j] += dp[i - 1][j];   // 从上面转移过来
                if(dp[i][j - 1] != -1) dp[i][j] += dp[i][j - 1];   // 从左边转移过来
            }
        }
        System.out.println(dp[x][y]);
    }
}
```

# 通配符

```c++
#include <bits/stdc++.h>
using namespace std;

string s, t;
set<int> S;

void DFS(int i, int j){
    if(j==t.length())
        S.insert(i);
    if(i==s.length())
        return;
    if(s[i]==t[j])
        DFS(i+1, j+1);
    else if(t[j]=='*'){
        DFS(i, j+1);
        DFS(i+1, j);
        DFS(i+1, j+1);
    }
    return;
}

int main(){
    cin>>t>>s;
    bool flag = false;
    for(int i=0;i<s.length();i++){
        if(s[i]==t[0] || t[0]=='*'){
            DFS(i, 0);
            if(!S.empty()){
                flag = true;
                for(set<int>::iterator it=S.begin();it!=S.end();it++)
                    if(*it>i)
                        cout<<i<<" "<<*it-i<<endl;
            }
            S.clear();
        }
    }
    if(!flag)
        cout<<-1<<" "<<0<<endl;
    return 0;
}
```

# 物流中转站

```c++
// 所有1点到达某个0点(x,y)的距离和 = 每行1点的数量 * 行间距 + 每列1点的数量 * 列间距
// 所以我们只需分别记录每行和每列1的数量和所有0点的坐标即可
#include <iostream>
#include <vector>
#include <limits>
using namespace std;

int main(){
    int n;
    cin >> n;
    //分别存储每行的1和每列的1数量
    vector<vector<int> > cnts(2, vector<int> (n, 0)); 
    //候选点（0点）的坐标
    vector<pair<int, int> > points;
    int cnt, temp;
    for(int i = 0; i<n; ++i){
        for(int j = 0; j<n; ++j){
            cin >> temp;
            //记录每行和每列的1的数量
            if(temp) {
                ++cnts[0][i];
                ++cnts[1][j];
            }
            else{
                //将0点的坐标记录到points中
                points.push_back(make_pair(i, j));
            }
        }
    }
    if(points.empty()){
        cout << -1 << endl;
    }
    else{
        //计算每个0坐标的距离和，得到最大值
        int min = numeric_limits<int>::max(), cur_dist;
        for(auto pnt : points){
            cur_dist = 0;
            //pnt.first横坐标，对应其他行的1之和，表示纵向路径和
            //pnt.second纵坐标，对应其他列的1之和，表示横向路径和
            for(int i = 0; i<n; ++i){
                if(i!=pnt.first) cur_dist += abs(i-pnt.first)*cnts[0][i];
                if(i!=pnt.second) cur_dist += abs(i-pnt.second)*cnts[1][i];
            }
            if(cur_dist<min) min = cur_dist;
        }
        cout << min << endl;
    }
    return 0;
}
```

# 礼物

```c++
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<vector>
#include<queue>
using namespace std;
int fa[100005], weight[100005], dp[100005][2];
bool leaf[100005];
int dp_dfs(int x){
    if(dp[x][0]==0){
        dp_dfs(fa[x]);
        dp[x][0] = max(weight[x], dp[fa[x]][0]);
        dp[x][1] = min(weight[x], dp[fa[x]][1]);
    }
    return 0;
}
int main()
{
    int T,n,x,y;
    scanf("%d",&T);
    for(int t=1;t<=T;t++)
    {
        scanf("%d",&n);
        memset(fa,0,sizeof(fa));
        memset(dp,0,sizeof(dp));
        for(int i=0; i<n; i++){
            scanf("%d",&weight[i]);
            leaf[i] = true;
        }
        for(int i=0; i<n-1; i++){
            scanf("%d %d",&x,&y);
            fa[y] = x;
            leaf[x] = false;
        }
        dp[0][0] = dp[0][1] = weight[0];
        int max_diff = 0;
        for(int i=0; i<n; i++){
            if(leaf[i]){
                dp_dfs(i);
    max_diff = max(max_diff, dp[i][0]-dp[i][1]);
            }
        }
        printf("%d\n", max_diff);
    }
    return 0;
}
```

# 罗马转数字

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return int整型
     */
    public int romanToInt (String s) {
        // write code here
        if(s == null || s.length() == 0)
            return 0;
        HashMap<Character, Integer> map = new HashMap<>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        int res = 0;
        for(int i = s.length() - 1; i >= 0; i--){
            if(i >= 1 && s.charAt(i) == 'V' && s.charAt(i - 1) == 'I'){
                res += 4;
                i --;
            }else if(i >= 1 && s.charAt(i) == 'X' && s.charAt(i - 1) == 'I'){
                res += 9;
                i --;
            }else if(i >= 1 && s.charAt(i) == 'L' && s.charAt(i - 1) == 'X'){
                res += 40;
                i --;
            }else if(i >= 1 && s.charAt(i) == 'C' && s.charAt(i - 1) == 'X'){
                res += 90;
                i --;
            }else if(i >= 1 && s.charAt(i) == 'D' && s.charAt(i - 1) == 'C'){
                res += 400;
                i --;
            }else if(i >= 1 && s.charAt(i) == 'M' && s.charAt(i - 1) == 'C'){
                res += 900;
                i --;
            }else
                res += map.get(s.charAt(i));
        }
        return res;
    }
}
```

# 四种写法

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        int start = 0;
        StringBuilder ans0 = new StringBuilder();
        StringBuilder ans1 = new StringBuilder();

        for (int i = 1; i < s.length(); i++) {
            char c = s.charAt(i);
            if ((c >= 'A' && c <= 'Z') || c == '-' || c == '_') {
                ans0.append(Character.toUpperCase(s.charAt(start))).append(s, start + 1, i);
                ans1.append(Character.toLowerCase(s.charAt(start))).append(s, start + 1, i).append('_');
                start = i;
                if (c == '-' || c == '_')
                    start++;
            }
        }
        String s1 = ans0.append(Character.toUpperCase(s.charAt(start))).append(s, start + 1, s.length()).toString();
        String s2 = ans1.append(Character.toLowerCase(s.charAt(start))).append(s, start + 1, s.length()).toString();

        System.out.print(s1 + " ");
        System.out.print(s1.substring(0, 1).toLowerCase() + s1.substring(1) + " ");
        System.out.print(s2+" ");
        System.out.println(s2.replaceAll("_", "-"));

    }
}
```

# 字符串式子 accaccacc

```java
package main
import "strings"
import "strconv"
/**
 * 
 * @param str string字符串 
 * @return string字符串
*/
func computeString( str string ) string {
    // write code here
    strStack := []string{}
    numStack := []int{}
    num, res := 0, ""
    for _, char := range str {
        if char >= '0' && char <= '9' {
            n, _ := strconv.Atoi(string(char))
            num = num * 10 + n
        } else if char == '[' {
            strStack = append(strStack, res)
            numStack = append(numStack, num)
            num, res = 0, ""
        } else if char == ']' {
            str := strStack[len(strStack)-1]
            count := numStack[len(numStack)-1]
            strStack = strStack[:len(strStack)-1]
            numStack = numStack[:len(numStack)-1]
            res = str + strings.Repeat(res, count)
        } else if char == '*'{
            continue
        } else {
            res += string(char)
        }
    }
    return res
}
```

# 二叉查找树 前序 叶子

```c++
#include <vector>
#include <string>
#include <iostream>
using namespace std;

int findindex(int start, int end, vector<int>& a, int target) {
    int i;
    for (i = start; i <= end; ++i) {
        if (a[i] > target) return i;
    }
    return i;
}

void shit(int start, int end, vector<int>& a) {
    // cout << start << end << endl;
    if (start > end) return;
    else if (start == end) {
        cout << a[start] << " ";
        return;
    }
    else {
        int index = findindex(start+1, end, a, a[start]);
        if (index <= end) {
            shit(start+1, index-1, a);
            shit(index, end, a);
        }
        else {
            shit(start+1, index-1, a);
        }
        
    }
}

int main() {
    vector<int> gyh;
    char c;
    int t;
    do {
        scanf("%d", &t);
        gyh.push_back(t);
        scanf("%c", &c);
    } while (c == ' ');
    shit(0, gyh.size()-1, gyh);
}
```

# 有效字符串

```c++
class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    bool checkValidString(string s) {
        // write code here
        int l=0,r=0;
        for(int i=0;i<s.length();i++){
            l+=s[i]==')'?-1:1;
            r+=s[s.length()-1-i]=='('?-1:1;
            if(l<0||r<0)
                return false;
        }
        return true;
    }
};
```

# 单链表隔断反转

```java
public class Solution {
    /**
     * reverse the given linked list
     * @param head ListNode类 the head of the linked list
     * @param n int整型 the N
     * @return ListNode类
     */
    public ListNode reverseLinkedList (ListNode head, int n) {
        if(head == null) return null;
        ListNode a = head;
        ListNode b = head;
        for(int i = 0; i < n; i++){
            if(b == null) break;
            b = b.next;
        }
        ListNode newHead = newReverse(a,b);
        a.next = reverseLinkedList(b,n);
        return newHead;
    }
    //可以参考LeetCOde反转链表,多一个条件:当前节点不为尾节点b
    public ListNode newReverse(ListNode a, ListNode b){
        ListNode pre = null;
        ListNode cur = a;
        while(cur != null && cur != b){
            ListNode tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
```

# 最后出现的字符

```js
function lastUniqueChar( str ) {
    if(!str) return "";
    //uniques数组按序存放str中只出现一次的字符
    var uniques=[];
    var strLen=str.length;
    for(let i=0;i<strLen;i++){
        if(str.indexOf(str[i])===str.lastIndexOf(str[i])){
            uniques.push(str[i]);
        }
    }
    //一定不要漏掉全都是重复出现的字符的情况
    if(uniques.length===0)
        return "";
    else
        return uniques[uniques.length-1];
}
module.exports = {
    lastUniqueChar : lastUniqueChar
};
```

