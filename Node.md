# 事件循环

- **阶段概述**

  - **定时器（timer）**：本阶段执行已经被setTimeout()和setInterval()的调度回调函数
  - **待定回调（pending callbacks）**：执行延迟到下一个循环迭代的I/O回调
  - **idle,prepare**：仅系统内部使用
  - **轮询（poll）**：检索新的I/O事件;执行与I/O相关的回调(几乎所有的情况下,除了关闭的回调函数,那些由计数器和setImmediate()调度的之外),其余情况Node将在适当的时候在此阻塞
  - **检测（check）**：setImmediate()回调函数在这个阶段执行
  - **关闭的回调函数（close）**：一些关闭的回调函数,如: socket.on(‘close’ , ...);

- **定时器**

  执行被setTimeout()和setInterval()的调度并且已经到达阈值的回调函数。但并不是用户希望其执行的确切时间。在指定的一段时间间隔后，计时器回调将被尽可能早地运行。

- **待定回调**

  在这个阶段将会执行一些系统的callback操作，比如在创建TCP连接的时候，TCP scoket接收到了ECONNREFUSED信号，在某些Linux操作系统中将会上报这个错误，那么这个系统的callback将会放到此阶段运行

- **轮询**

  - 功能：

    - 计算应该阻塞和轮询I/O的时间
    - 处理轮询队列里的事件.

  - 详述

    当事件循环进入轮询阶段且没有被调度的计时器时,将发生以下两种情况:

    - 如果 **轮询** 队列**不为空**的，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制
    - 如果轮询队列**为空**：
      - 如果脚本被 setImmediate() 调度，则事件循环将结束至 轮询阶段，并继续检查阶段以执行那些被调度的脚本。
      - 如果脚本未被setImmediate()调度，则事件循环将等待回调被添加到队列中，然后立即执行。

    一旦轮询队列为空，事件循环将检查已达到事件阈值的计时器。如果已有计时器准备就绪，则事件循环将绕回计时器阶段已执行这些计时器的回调。

- **检查阶段**

  如果轮询极端变为空闲状态，并且脚本使用 setImmediate() 后被排列在队列中，则事件循环可能继续到 检查 阶段而不是等待。

  setImmedaite() 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个来libuv API 安排回调在轮询阶段完成后执行。

  通常，在执行代码时，事件循环最终会命中轮询阶段，在那等待传入连接、请求等。但是，如果回调已使用 `setImmediate()`调度过，并且轮询阶段变为空闲状态，则它将结束此阶段，并继续到检查阶段而不是继续等待轮询事件。

- **关闭的回调函数**

  如果套接字或处理函数突然关闭（例如 `socket.destroy()`），则`'close'` 事件将在这个阶段发出。否则它将通过 `process.nextTick()` 发出。

- setImmediate() 和 setTimeout()

  - 调用时机:

    - setImmediate() 设计为一旦在当前轮询阶段完成,就执行脚本
    - setTimeout() 在最小阈值过后运行脚本

  - 执行顺序:

    根据调用它们的上下文而异.

    - 主模块调用：执行顺序会受进程性能的约束。
    - I/O循环内调用时setImmediate总是被优先调用。

- **process.nextTick()**

  任何时候在给定的阶段调用 `process.nextTicke()` , 所有传递到 `process.nextTick()` 的回调将在事件循环继续之前解析执行。

  - 为什么使用
    - 允许用户处理错误，清理任何不需要的资源，或则在事件循环之前重试请求。
    - 有时有让回调在栈展开后，但在事件循环继续之前运行的必要
